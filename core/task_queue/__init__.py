import uuid
import json
import logging
from enum import Enum
from datetime import datetime
from typing import Optional, Dict, Any, List, Type
from pydantic import BaseModel, Field, ConfigDict

from sqlalchemy import Column, String, Integer, DateTime, Text, JSON, select, desc
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.exc import SQLAlchemyError

from core.database import Base, Database, session_context

logger = logging.getLogger("core.task_queue")

# --- Enums ---
class TaskStatus(str, Enum):
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"

# --- Pydantic Models ---
class BackgroundTask(BaseModel):
    task_id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str # e.g. "summarise_document"
    params: Dict[str, Any] = Field(default_factory=dict)
    
    status: TaskStatus = TaskStatus.PENDING
    result: Optional[Any] = None # JSON serializable
    error: Optional[str] = None
    
    created_at: datetime = Field(default_factory=datetime.now)
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    
    retry_count: int = 0
    max_retries: int = 3

    model_config = ConfigDict(use_enum_values=True)

# --- SQLAlchemy Models ---
class TaskModel(Base):
    __tablename__ = 'background_tasks'
    
    task_id = Column(String, primary_key=True)
    name = Column(String, nullable=False)
    params = Column(JSON, nullable=False, default={})
    
    status = Column(String, default=TaskStatus.PENDING.value)
    result = Column(JSON, nullable=True)
    error = Column(Text, nullable=True)
    
    created_at = Column(DateTime, default=datetime.now)
    started_at = Column(DateTime, nullable=True)
    completed_at = Column(DateTime, nullable=True)
    
    retry_count = Column(Integer, default=0)
    max_retries = Column(Integer, default=3)

# --- Interfaces ---
class TaskQueue:
    async def enqueue(self, name: str, params: Dict[str, Any], max_retries: int = 3) -> BackgroundTask:
        raise NotImplementedError

    async def get_task(self, task_id: str) -> Optional[BackgroundTask]:
        raise NotImplementedError

    async def update_status(self, task_id: str, status: TaskStatus, result: Any = None, error: str = None) -> BackgroundTask:
        raise NotImplementedError

    async def list_tasks(self, status: Optional[TaskStatus] = None, limit: int = 50) -> List[BackgroundTask]:
        raise NotImplementedError
    
    async def claim_next_task(self) -> Optional[BackgroundTask]:
        """Atomically claim the next pending task."""
        raise NotImplementedError

# --- Implementations ---
class SQLAlchemyTaskQueue(TaskQueue):
    def __init__(self, db: Database):
        self.db = db

    async def _get_session(self):
        """Helper to get current request session or create a temporary one."""
        session = session_context.get()
        if session:
            return session
        return self.db.async_session_factory() # Returns context manager!

    async def enqueue(self, name: str, params: Dict[str, Any], max_retries: int = 3) -> BackgroundTask:
        task = BackgroundTask(name=name, params=params, max_retries=max_retries)
        
        db_task = TaskModel(
            task_id=task.task_id,
            name=task.name,
            params=task.params,
            status=task.status.value,
            max_retries=task.max_retries,
            created_at=task.created_at
        )

        session = session_context.get()
        if session:
             session.add(db_task)
             await session.flush() # Ensure ID is gathered if autogenerated (ours is uuid so ok)
        else:
             async with self.db.async_session_factory() as session:
                 session.add(db_task)
                 await session.commit()
                 
        logger.info(f"Task enqueued: {task.task_id} ({name})")
        return task

    async def get_task(self, task_id: str) -> Optional[BackgroundTask]:
        stmt = select(TaskModel).where(TaskModel.task_id == task_id)
        
        # Helper to execute
        async def _exec(sess):
            res = await sess.execute(stmt)
            return res.scalar_one_or_none()

        session = session_context.get()
        if session:
            row = await _exec(session)
        else:
            async with self.db.async_session_factory() as session:
                row = await _exec(session)
        
        if not row:
            return None
        
        return self._to_pydantic(row)

    async def update_status(self, task_id: str, status: TaskStatus, result: Any = None, error: str = None) -> Optional[BackgroundTask]:
        
        async def _update(sess):
            stmt = select(TaskModel).where(TaskModel.task_id == task_id)
            res = await sess.execute(stmt)
            row = res.scalar_one_or_none()
            
            if not row:
                return None
                
            row.status = status.value
            if result is not None:
                row.result = result
            if error is not None:
                row.error = error
                
            if status == TaskStatus.RUNNING:
                row.started_at = datetime.now()
            elif status in [TaskStatus.COMPLETED, TaskStatus.FAILED, TaskStatus.CANCELLED]:
                row.completed_at = datetime.now()
            
            return row

        session = session_context.get()
        if session:
            row = await _update(session)
            # Commit handled by caller context
        else:
            async with self.db.async_session_factory() as session:
                row = await _update(session)
                await session.commit()
                
        return self._to_pydantic(row) if row else None

    async def list_tasks(self, status: Optional[TaskStatus] = None, limit: int = 50) -> List[BackgroundTask]:
        stmt = select(TaskModel).order_by(desc(TaskModel.created_at)).limit(limit)
        if status:
            stmt = stmt.where(TaskModel.status == status.value)

        session = session_context.get()
        if session:
            res = await session.execute(stmt)
            rows = res.scalars().all()
        else:
            async with self.db.async_session_factory() as session:
                res = await session.execute(stmt)
                rows = res.scalars().all()
                
        return [self._to_pydantic(row) for row in rows]
    
    async def claim_next_task(self) -> Optional[BackgroundTask]:
        """
        Naive implementation: Find first PENDING, mark as RUNNING.
        In distributed system, requires SELECT FOR UPDATE or similar lock.
        """
        async def _claim(sess):
            # Select first pending
            stmt = select(TaskModel).where(TaskModel.status == TaskStatus.PENDING.value).order_by(TaskModel.created_at).limit(1)
            # For strict concurrency, we'd need with_for_update, but it's driver dependent.
            # SQLite supports it but specific syntax. Postgre/MySQL do.
            # Let's try simple read-modify-write for now as we are single-instance mostly.
            
            res = await sess.execute(stmt)
            row = res.scalar_one_or_none()
            
            if not row:
                return None
                
            row.status = TaskStatus.RUNNING.value
            row.started_at = datetime.now()
            return row

        session = session_context.get()
        if session:
             # Should ideally be its own transaction to avoid holding main request tx?
             # But if claimed, we want it committed fast. 
             row = await _claim(session)
             # If external session, caller commits. 
        else:
             async with self.db.async_session_factory() as session:
                 row = await _claim(session)
                 await session.commit()
        
        return self._to_pydantic(row) if row else None

    def _to_pydantic(self, row: TaskModel) -> BackgroundTask:
        return BackgroundTask(
            task_id=row.task_id,
            name=row.name,
            params=row.params or {},
            status=TaskStatus(row.status),
            result=row.result,
            error=row.error,
            created_at=row.created_at,
            started_at=row.started_at,
            completed_at=row.completed_at,
            retry_count=row.retry_count,
            max_retries=row.max_retries
        )
